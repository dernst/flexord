#' Helper functions for K-centroids clustering using GDM2 distance
#'
#' `distGDM2` implements the GDM2 distance as first presented by Walesiak (1993)
#' and extended to usage in K-centroids clustering in Ernst et. al (2025).
#' 
#' `.projectIntofx` is a helper function factory that creates a function that
#' will project an arbitrary object into the space of the empirical PDF and CDF
#' of a matrix x.
#' 
#' `kccafamilyGDM2` is a wrapper for `flexclust::kccaFamily` that fills out
#' the slots `dist=distGDM2` and `genDist=.projectIntofx`. It is then to be
#' used for clustering using the GDM2 distance in `flexclust::kcca` and functions
#' built upon it.
#'
#' @param x A numeric matrix of ordinal data points. The ordinal variables
#'    need to be coded as `1:length(levels(x[,i]))`.
#' @param centers A numeric matrix of cluster centers.
#' @param genDist Function for creating a distance function that will be
#'    primed on `x`. Argument is not used if `distGDM2` is used within
#'    `flexclust::kcca`. In this case, the `genDist` information is inferred
#'    from the `kccaFamily` object.
#' @param xrange Range specification for the variables. Possible values are:
#'   - `NULL` (default): defaults to `'data range'`.
#'   - `'data range'`: Uses the range of the entire dataset.
#'   - `'variable specific'`: Uses column-specific ranges.
#'   - A numeric vector: Applies the same range to all columns.
#'   - A list of numeric vectors: Specifies column-specific ranges.
#' @param ... Additional arguments passed to compatibility functions.
#' @param new_x A numeric matrix for prediction when using the function 
#'   generated by `.projectIntofx`, which has been primed on the empirical
#'   PDF and CDF of `x`.
#' @param cent See [flexclust::kccaFamily()]: Function for determining cluster
#'   centroids. `NULL` defaults to `centOptim`, a general purpose optimizer.
#' @param preproc See [flexclust::kccaFamily()]: Preprocessing function to be applied to the data before clustering.
#' @param trim See [flexclust::kccaFamily()]: Proportion of points trimmed in robust clustering.
#' @param groupFun See [flexclust::kccaFamily()]: A character string specifying the function for clustering.
#'   Default is `'minSumClusters'`.
#'
#' @return
#' - `distGDM2`: A distance matrix for each row in `x` from the `centers` in the
#'    clustering process.
#' - `.projectIntofx`: A function that will project a new data object `new_x`
#'    into the space of `x`'s epdf, ecdf, and \( \tilde{F} \).
#' - `kccaFamilyGDM2`: A custom `kccaFamily` object using `distGDM2` as the 
#'    distance function. To be used within `flexclust::kcca` or functions
#'    that build upon it.
#'
#' @examples
#' ## Example usage
#' #creating a distance matrix between two matrices based on GDM2 distance
#' data <- matrix(sample(1:5, 50, replace = TRUE),
#'                nrow = 10, ncol = 5)
#' initcenters <- data[sample(1:10, 3),]
#' distGDM2(data, initcenters, genDist=.projectIntofx)
#' 
#' #K-centroids clustering using GDM2 distance
#' flexclust::kcca(data, k=3, family=kccaFamilyGDM2())
#'
#'#' @export
distGDM2 <- function(x, centers,  genDist=NULL, xrange=NULL, ...) {
  if (ncol(x) != ncol(centers))
    stop(sQuote('x'), ' and ', sQuote('centers'), ' must have the same number of columns')
  z <- matrix(0, nrow=nrow(x), ncol=nrow(centers))
  
  if(!is.null(genDist)) {
    if(!is.function(genDist)) stop("Error: parameter genDist is not a function.")
    fmly <- kccaFamilyGDM2()
    fmly@genDist$genDist <- fmly@genDist$genDist(x, xrange)
    fmly@genDist$storage <- fmly@genDist$genDist(x)
  } else {
    whereisfamily <- sapply(sys.frames(), ls)
    whereisfamily <- which(sapply(whereisfamily, function(y) "family" %in% y))[1]
    if(!is.na(whereisfamily)) {
      fmly <- get('family', envir=sys.frame(whereisfamily),
                  inherits=FALSE)
    } else {
      fmly <- get('from', envir=parent.frame())
      fmly <- fmly@family
    }
  }
  
  N <- nrow(x)
  fx <- fmly@genDist$storage
  fc <- fmly@genDist$genDist(centers)
  
  for(k in 1:nrow(centers)) {
    for(i in 1:N) {
      deltaeq <- x[i,]==centers[k,]
      numneq <- (!deltaeq)*(1/N + 2*abs(fx$Ftildex[i,]-fc$Ftildex[k,]))
      numeq <- deltaeq*fx$epdf[i,]
      denom <- sqrt(sum(1-fx$epdf[i,])*sum(1-fc$epdf[k,]))
      
      z[i,k] <- (1-(sum(1-numneq-numeq)/denom))/2
    }
  }
  z 
}

#' @export
.projectIntofx <- function(x, xrange=NULL){
  if(is.null(xrange)) xrange <- 'data range'
  
  if(sum(xrange=='data range')) {
    rng <- rep(range(x, na.rm=TRUE), ncol(x)) |> matrix(nrow=2)
  } else if(sum(xrange=='variable specific')) {
    rng <- apply(x, 2, range, na.rm=TRUE)
  } else if(is.vector(xrange, mode='numeric')) {
    rng <- rep(xrange, ncol(x)) |> matrix(nrow=2)
  } else {
    if(length(xrange) != ncol(x))
      stop('Either supply 1 range vector, or list of ranges for all variables')
    rng <- unlist(xrange) |> matrix(nrow=2)
  }
  
  hats <- lapply(1:ncol(x), function(y) {
    level <- factor(x[,y], levels=seq(rng[1,y], rng[2,y]))
    pdf <- table(level)/nrow(x)
    pdf <- as.data.frame.table(pdf)
    pdf$level <- as.numeric(pdf$level)
    
    epdf <- function(i) {
      ind <- which(pdf[,'level'] <= i)
      if(length(ind) == 0) {
        return(0)
      } else {
        return(pdf$Freq[ind[length(ind)]])
      }
    }
    list(epdf=epdf, ecdf=ecdf(x[,y]))
  })
  
  names(hats) <- colnames(x)
  
  function(new_x) {
    fxs <- sapply(c('epdf', 'ecdf'), function(type) {
      z <- matrix(0, nrow=nrow(new_x), ncol=ncol(new_x),
                  dimnames=dimnames(new_x))
      for(j in 1:ncol(new_x)) {
        for(i in 1:nrow(new_x)) {
          z[i,j] <- hats[[j]][[type]](new_x[i,j])
        }
      }
      z
    }, simplify = FALSE)
    fxs$Ftildex <- fxs$ecdf - (fxs$epdf/2)
    return(fxs)
  }
}

#' @export
kccaFamilyGDM2 <- function(cent=NULL, preproc=NULL, trim=0,
                           groupFun='minSumClusters') {
  kccaFamily(dist=distGDM2, cent=cent, preproc=preproc,
             trim=trim, genDist=function(x, xrange) .projectIntofx(x, xrange),
             groupFun=groupFun)
}
